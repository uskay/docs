---
class: post-blog post-detail
type: Blog
$title: "Streaming in the Shadow Reader"
id: ads-streaming-in-the-shadow-reader
author: Ben Morss
role:  Developer Advocate for AMP, at Google
origin: "https://amphtml.wordpress.com/2018/11/05/streaming-in-the-shadow-reader/amp/"
excerpt: "What did we do? We made The Shadow Reader faster again! We created The Shadow Reader (https://amp.cards) to demonstrate how AMP pages can be used within a Progressive Web App (PWA) (read our announcement post for more context). The site folds real articles from The Guardian into an immersive news reader experience. It&#8217;s a demo, but [&#8230;]"
avatar: https://1.gravatar.com/avatar/42ecb1ea497ca9d0ffe1e406cae70e27?s=96&d=identicon&r=G
date_data: 2018-11-05T13:42:20-08:00
$date: November 5, 2018
$parent: /content/latest/list-blog.html
$path: /latest/blog/{base}/
$localization:
  path: /{locale}/latest/blog/{base}/
components:
  - social-share
  - anim
inlineCSS: .amp-wp-inline-329fdb7771c10d07df9eb73273c95a60{font-weight:400;}
---

<div class="amp-wp-article-content">

		<h3><b>What did we do?</b></h3><p><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">We made <a href="https://amp.cards">The Shadow Reader</a> faster again!</span></p><p><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">We created </span><a href="https://amp.cards"><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">The Shadow Reader</span></a><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60"> <a href="http://(https://amp.cards)">(https://amp.cards)</a> to demonstrate how AMP pages can be used within a Progressive Web App (PWA) (read our </span><a href="https://www.ampproject.org/latest/blog/putting-the-amp-in-progressive-web-amps-meet-the-shadowreader/"><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">announcement post</span></a><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60"> for more context). The site folds real articles from </span><a href="https://www.theguardian.com"><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">The Guardian</span></a><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60"> into an immersive news reader experience. It’s a demo, but it’s also a fully functional site, containing everything you need to embed AMPs inside a beautiful PWA.</span></p><p><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">Earlier this year, we </span><a href="https://www.ampproject.org/latest/blog/ads-the-shadow-reader-improved/"><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">enhanced</span></a><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60"> the Shadow Reader to follow an AMP=&gt;AMP/PWA pattern, which made initial article loads faster and made the entire app more SEO-friendly. Now, we’ve made the site even faster by adding DOM streaming. That means the browser can render content as it loads – it doesn’t have to wait until the full load!</span></p><p><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">The video below shows the new streaming Shadow Reader on the left and the old version on the right. To clearly see the difference streaming makes, I used <a href="https://www.charlesproxy.com">Charles proxy</a> to simulate a 56kbps connection. Though this is obviously worse than the average connection, the Shadow Reader was already quite fast!  In AMPs, all JavaScript is asynchronous. And in many AMPs, including The Guardian’s, most of the HTML consists of CSS in the <code>&lt;head&gt;</code>. There isn’t that much <code>&lt;body&gt;</code> to stream! So it’s tough to spot the difference on a good connection, or even in a 3G connection simulated in DevTools.</span></p><p><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">It takes a little while to load the HTML in the <code>&lt;head&gt;</code>, so this video starts a few seconds in. Once we get to the <code>&lt;body&gt;</code>, the streaming works its magic, and in my unlablike test environment, the main article text was entirely visible 11 seconds earlier with streaming than without. Interestingly, the article’s YouTube thumbnail showed up right after the text in the streaming version, whereas in non-streaming, it showed up 67 seconds later than it did in the streaming version.</span></p><p><amp-anim class=" size-full wp-image-2236 aligncenter amp-wp-enforced-sizes" src="https://amphtml.files.wordpress.com/2018/11/streaming_compared.gif?w=660" alt="streaming_compared" width="470" height="451" sizes="(min-width: 470px) 470px, 100vw"></amp-anim></p><h3></h3><p> </p><h3><b>How does this work?</b></h3><p><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">AMP comes in a flavor called </span><a href="https://www.ampproject.org/docs/integration/pwa-amp/amp-in-pwa"><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">Shadow AMP</span></a><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">, which allows an AMP to exist entirely within a </span><a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM"><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">shadow root</span></a><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">. Shadow AMP lets you embed an AMP in another webpage. You create a shadow AMP like this:</span></p><pre><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">const shadowDoc = AMP.attachShadowDoc(container, doc, url);</span></pre><p><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">If you’ve read </span><a href="https://jakearchibald.com/2016/fun-hacks-faster-content/"><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">Jake Archibald’s post</span></a><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60"> on the subject, you know that it’s possible to stream content into the DOM via a trick involving an <code>&lt;iframe&gt;</code>. What you may not know is that </span><a href="https://github.com/ampproject/amphtml/pull/9495"><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">this technique has been used</span></a><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60"> to stream AMP content into a shadow root!  You simply create the shadow AMP with a different method:</span></p><pre><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">const shadowDoc = AMP.attachShadowDocAsStream(container, url); </span></pre><p><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">Here’s how you stream AMP content into a shadow root, in 4 steps:</span></p><ol><li class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60"><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">Create the streaming shadow AMP</span></li>
<li class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60"><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">Access your content with </span><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">fetch()</span></li>
<li class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60"><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">Stream that content into the shadow AMP.</span></li>
<li class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60"><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">When </span><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">fetch()</span><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60"> tells you it’s done, close the writer.</span></li>
</ol><h3><b><br/>
The four steps</b></h3><p><b>1. Create the streaming shadow AMP. </b><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">See above.</span></p><p><b>2. Access your content with fetch(). </b>Open a fetch() to the AMP URL. fetch() returns a promise that resolves to a response object. This object is a stream. Usually you’d use a method that read the stream to completion, then processed it in some way. For example, you might use response.text() or response.blob(), like this:</p><pre><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">fetch('example.com/amp.html')
</span><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">.then(response =&gt; response.text())
</span><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">.then(text =&gt; console.log(text));</span></pre><p><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">In our case, though, we’re going to use the </span><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">response</span><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60"> object as a stream. That’s easy to access via its </span><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">body</span><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60"> property, which exposes a </span><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">ReadableStream</span><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">.</span></p><pre><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">fetch('example.com/amp.html')
</span><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">.then(response =&gt; response.body())
</span><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">.then( // read from the ReadableStream );</span></pre><p><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">That </span><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">ReadableStream </span><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">contains a </span><a href="https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/getReader"><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">getReader()</span></a><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60"> method which locks the stream and returns a </span><a href="https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamDefaultReader"><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">ReadableStreamDefaultReader</span></a><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">. </span><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">The </span><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">ReadableStreamDefaultReader</span><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60"> exposes a </span><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">read()</span><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60"> method that provides access to chunks of HTML as they stream in, like this:</span></p><pre><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">// read from the ReadableStream
</span><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">let reader = response.body.getReader();
</span><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">let chunk = await reader.read();</span></pre><p><b><br/>
3. Stream that content into the shadow AMP. </b><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">Meanwhile, the </span><a href="https://github.com/ampproject/amphtml/blob/master/spec/amp-shadow-doc.md#shadow-doc-api"><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">shadowDoc</span></a><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60"> we’ve created contains a </span><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">writer</span><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60"> object, and that writer contains </span><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">write</span><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60"> and </span><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">close</span><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60"> methods that can be used for streaming. So you can stream content into the DOM like this:</span></p><pre><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">shadowDoc.writer.write(html);</span></pre><p><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">and close it like this:</span></p><pre><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">shadowDoc.writer.close();</span></pre><p><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">So once we have the stream reader and the shadowDoc streamer, we repeat the following steps:</span></p><ul><li class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60"><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">get chunk from stream</span></li>
<li class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60"><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">decode chunk and write it into the DOM</span></li>
</ul><p><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">until the stream reader tells us it’s done, which it does through a boolean.</span></p><p><a href="https://github.com/ampproject/amphtml/blob/master/examples/pwa/pwa.js"><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">One way to do this</span></a><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60"> is through recursion. In the Shadow Reader, we used await. Here’s the gist of our streaming code:</span></p><pre>   const shadowDoc = AMP.attachShadowDocAsStream(container, url);
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">    fetch(url).then(async response =&gt; {</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">      let reader = response.body.getReader();</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">      let decoder = new TextDecoder();</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">      while (true) {</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">        let chunk = await reader.read();</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">        if (chunk.done) {</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">          shadowDoc.writer.close();</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">          break;</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">        }</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">        let html = decoder.decode(</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">          chunk.value || new Uint8Array(),</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">          {stream: !chunk.done}</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">        );</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">        if (html) {</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">          shadowDoc.writer.write(html);</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">        }</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">      }</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">    });</span></pre><p><b><br/>
4. When </b><b>fetch()</b><b> tells you it’s done, close the writer. </b><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">Looks like we covered that in step 3 above. And Bob’s your uncle!</span></p><p><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">Wait, you say – what about browsers that don’t yet support streaming?  Fortunately, in such cases, a call to AMP.attachShadowDocAsStream() </span><a href="https://github.com/ampproject/amphtml/blob/5b9874396a8cc44cfb1a344cd38f143cf01a680b/src/shadow-embed.js#L373"><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">gracefully degrades</span></a><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60"> to the same functionality as AMP.attachShadowDoc().</span></p><p><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">The Shadow Reader loads and prerenders the top three articles when the app loads. We didn’t use streaming for these, and just to be on the safe side, we also don’t use streaming for browsers that don’t support it. You can conveniently compare the streaming and non-streaming approaches in the code by looking at </span><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">load()</span><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60"> and </span><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">stream()</span><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60"> in Article.js.</span></p><h3></h3><p> </p><h3><b>Reality is complicated.</b></h3><p><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">What would life be without a complexity or two?</span></p><p><b>Testing.</b><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60"> If you’re like me, you’d like to see the streaming happen, chunk by chunk, by inserting a breakpoint into the streaming code. But this may not give the desired result. At the time I’m writing this, with breakpoints set in Chrome, the shadow root remains invisible until it’s closed. You can see streaming more easily if you use DevTools to throttle your connection to 2G. It works even better to use a proxy server that sends content in smaller chunks. Or to test with an exceptionally large AMP, since many AMPs contain little HTML, and the entire content may arrive in only 2 chunks or even 1.</span></p><p><b>Order of operations. </b><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">Before streaming, the Shadow Reader showed a loading spinner, loaded the article, rendered it in a hidden div, then removed the spinner and showed the article. With streaming, we want to show the article immediately!  This meant we had to move around some of the animations. It also meant that any modification of the AMP had to occur immediately, not after it fully loaded. In particular:</span></p><p><b>Hiding unwanted bits of the AMP. </b><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">When the Shadow Reader imports an AMP, it </span><a href="https://paulbakaus.com/tutorials/html5/building-a-pwamp-0-introducing-the-shadowreader/"><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">needs to remove</span></a><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60"> the original article’s menu, header, or footer, since those are already part of the PWA, and it would be silly to have, say, two menus. The Shadow Reader used to create the whole article in the DOM, remove the unwanted bits, then display the sanitized article. With streaming, we have to instead never show the unwanted elements in the first place. We could filter out unwanted elements as HTML came in, but this is difficult. Instead, we simply hide those elements with CSS.</span></p><p><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">Normally this is simple. AMP automatically applies an </span><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">amp-shadow</span><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60"> class to the shadow root, which allows you to easily style an AMP differently when it’s in a shadow root. Unfortunately, in our case, we don’t control the Guardian articles. We solve this by looking for a chunk that contains <code>&lt;style amp-custom&gt;</code>, and then injecting our CSS right into that.</span></p><p><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">This is useful anyway, because the Shadow Reader included a custom stylesheet in the AMP. Unfortunately, during streaming, a browser can’t be counted on to load and apply CSS as soon as it sees a <code>&lt;style&gt;</code> tag – it may wait until streaming is done. We solve this problem by injecting the custom stylesheet as well. Done!  Here’s the actual final streaming code:</span></p><pre><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">    </span><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">fetch(this.proxyUrl).then(async response =&gt; {</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">      let reader = response.body.getReader();</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">      let decoder = new TextDecoder();</span>

<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">      while (true) {</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">        let chunk = await reader.read();</span>

<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">        if (chunk.done) {</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">          shadowDoc.writer.close();</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">          break;</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">        }</span>

<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">        let html = decoder.decode(</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">          chunk.value || new Uint8Array(),</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">          {stream: !chunk.done}</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">        );</span>

<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">        // check each chunk of HTML to see if it contains &lt;style amp-custom&gt;. If so, add in some extra CSS.</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">        if (html) {</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">          html = shadowReader.backend.injectCSS(html);</span>

<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">          // when we've got the body, start the process of animating the card and showing the article,</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">          // placing the card before the article</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">          if (html.includes('&lt;body')) {</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">            html = article.prependCardHtml(html);</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">            shadowDoc.writer.write(html);</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">            article.card.animate();</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">            article.show();
</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">          } else {</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">            shadowDoc.writer.write(html);</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">          }</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">        }</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">      }</span>
<span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">    });</span></pre><p><b><br/>
Left as an exercise for the reader. </b><span class="amp-wp-inline-329fdb7771c10d07df9eb73273c95a60">At press time, I have not dealt with an edge case: this fails if <code>&lt;body</code> is split between two chunks. Please submit a PR!</span></p><p><em>Posted by Ben Morss, Developer Advocate for AMP, at Google</em></p>	</div>

	

</div>

